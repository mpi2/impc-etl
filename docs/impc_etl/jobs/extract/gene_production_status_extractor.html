<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>impc_etl.jobs.extract.gene_production_status_extractor API documentation</title>
<meta name="description" content="Gene production status report extractor." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>impc_etl.jobs.extract.gene_production_status_extractor</code></h1>
</header>
<section id="section-intro">
<p>Gene production status report extractor.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    Gene production status report extractor.
&#34;&#34;&#34;
from typing import Dict, List

import luigi
from luigi.contrib.spark import PySparkTask
from pyspark import SparkContext
from pyspark.sql import SparkSession, DataFrame
from pyspark.sql.functions import (
    when,
    col,
    lit,
    lower,
    udf,
    collect_set,
    array_contains,
)
from pyspark.sql.types import StringType, IntegerType

from impc_etl.jobs.extract.product_report_extractor import ProductReportExtractor
from impc_etl.workflow.config import ImpcConfig


class GeneProductionStatusExtractor(PySparkTask):
    &#34;&#34;&#34;
    PySpark Task class to extract gene status information from tracking systems reports.
    This also maps the different status in the reports to the ones we use on the website.
    It takes as an input the Gene Interest report from gentar (https://www.gentar.org/tracker-api/api/reports/gene_interest)
    And the Products report from Gentar ().
    The output is a Parquet file containing a full report of the different Statuses available for a Gene.
    &#34;&#34;&#34;

    #: Name of the Spark task
    name: str = &#34;IMPC_Gene_Production_Status_Extractor&#34;

    #: Path in the filesystem (local or HDFS) to the GenTar gene status report
    gentar_gene_status_path: luigi.Parameter = luigi.Parameter()

    #: Path of the output directory where the new parquet file will be generated.
    output_path = luigi.Parameter()

    def output(self):
        &#34;&#34;&#34;
        Returns the full parquet path as an output for the Luigi Task (e.g. impc/dr15.2/parquet/gene_status_parquet)
        &#34;&#34;&#34;
        return ImpcConfig().get_target(f&#34;{self.output_path}gene_status_parquet&#34;)

    def requires(self):
        &#34;&#34;&#34;
        Returns the list of dependencies for the PySpark task.
        &#34;&#34;&#34;
        return [ProductReportExtractor()]

    def app_options(self):
        &#34;&#34;&#34;
        Generates the options pass to the PySpark job
        &#34;&#34;&#34;
        return [
            # Output of the only dependency
            self.input()[0].path,
            self.gentar_gene_status_path,
            self.output().path,
        ]

    def main(self, sc: SparkContext, *args):
        &#34;&#34;&#34;
        Takes in a SparkContext and the list of arguments generated by `app_options` and executes the PySpark job.
        &#34;&#34;&#34;
        spark: SparkSession = SparkSession(sc)
        product_parquet_path = args[0]
        gentar_gene_status_path = args[1]
        output_path = args[2]

        gentar_gene_status_df = spark.read.csv(
            gentar_gene_status_path, header=True, sep=&#34;\t&#34;
        )

        product_df = spark.read.parquet(product_parquet_path)
        product_df = product_df.select(&#34;mgi_accession_id&#34;, &#34;type&#34;).distinct()
        has_products = product_df.groupBy(&#34;mgi_accession_id&#34;).agg(
            collect_set(&#34;type&#34;).alias(&#34;product_types&#34;)
        )

        # Renaming gentar TSV columns to match the gene core
        gentar_column_map = {
            &#34;Gene Symbol&#34;: &#34;marker_symbol&#34;,
            &#34;MGI ID&#34;: &#34;mgi_accession_id&#34;,
            &#34;Assignment Status&#34;: &#34;assignment_status&#34;,
            &#34;ES Null Production Status&#34;: &#34;null_allele_production_status&#34;,
            &#34;ES Conditional Production Status&#34;: &#34;conditional_allele_production_status&#34;,
            &#34;Crispr Production Status&#34;: &#34;crispr_allele_production_status&#34;,
            &#34;Early Adult Phenotyping Status&#34;: &#34;phenotyping_status&#34;,
        }
        for col_name in gentar_gene_status_df.columns:
            new_col_name = (
                gentar_column_map[col_name]
                if &#34;mgi_accession_id&#34; not in gentar_column_map[col_name]
                else gentar_column_map[col_name]
            )
            gentar_gene_status_df = gentar_gene_status_df.withColumnRenamed(
                col_name, new_col_name
            )
        gene_status_df = gentar_gene_status_df

        # Resolve assigment statuses
        gene_statuses_cols = [
            &#34;mgi_accession_id&#34;,
            &#34;assignment_status&#34;,
            &#34;null_allele_production_status&#34;,
            &#34;conditional_allele_production_status&#34;,
            &#34;crispr_allele_production_status&#34;,
            &#34;es_cell_production_status&#34;,
            &#34;mouse_production_status&#34;,
            &#34;phenotyping_status&#34;,
        ]

        mice_production_status_cols = [
            &#34;null_allele_production_status&#34;,
            &#34;conditional_allele_production_status&#34;,
            &#34;crispr_allele_production_status&#34;,
        ]

        allele_mouse_prod_status_map = {
            &#34;Chimeras obtained&#34;: &#34;Assigned for Mouse Production and Phenotyping&#34;,
            &#34;Micro-injection in progress&#34;: &#34;Assigned for Mouse Production and Phenotyping&#34;,
            &#34;Cre Excision Complete&#34;: &#34;Mice Produced&#34;,
            &#34;Cre Excision Started&#34;: &#34;Mice Produced&#34;,
            &#34;Genotype confirmed&#34;: &#34;Mice Produced&#34;,
            &#34;Phenotype Attempt Registered&#34;: &#34;Mice Produced&#34;,
            &#34;Rederivation Complete&#34;: &#34;Mice Produced&#34;,
            &#34;Rederivation Started&#34;: &#34;Mice Produced&#34;,
        }

        # Collapse mouse production status
        gene_status_df = collapse_production_status(
            spark,
            gene_status_df,
            allele_mouse_prod_status_map,
            mice_production_status_cols,
            &#34;mouse_production_status&#34;,
        )

        assignment_status_es_cells_prod_status_map = {
            &#34;Aborted - ES Cell QC Failed&#34;: &#34;Not Assigned for ES Cell Production&#34;,
            &#34;Assigned - ES Cell QC In Progress&#34;: &#34;Assigned for ES Cell Production&#34;,
            &#34;Assigned - ES Cell QC Complete&#34;: &#34;ES Cells Produced&#34;,
        }

        # Collapse ES Cells production status
        gene_status_df = collapse_production_status(
            spark,
            gene_status_df,
            assignment_status_es_cells_prod_status_map,
            [&#34;null_allele_production_status&#34;, &#34;conditional_allele_production_status&#34;],
            &#34;es_cell_production_status&#34;,
        )

        # Map ES Cell production status
        allele_es_cells_prod_status_map = {
            &#34;Micro-injection in progress&#34;: &#34;Assigned for ES Cell Production&#34;,
            &#34;Chimeras obtained&#34;: &#34;ES Cells Produced&#34;,
            &#34;Genotype confirmed&#34;: &#34;ES Cells Produced&#34;,
            &#34;Micro-injection aborted&#34;: &#34;Not Assigned for ES Cell Production&#34;,
        }

        map_allele_es_cells_udf = udf(
            lambda x: allele_es_cells_prod_status_map[x]
            if x in allele_es_cells_prod_status_map
            else None,
            StringType(),
        )

        gene_status_df = gene_status_df.withColumn(
            &#34;es_cell_production_status&#34;,
            map_allele_es_cells_udf(&#34;conditional_allele_production_status&#34;),
        )
        gene_status_df = gene_status_df.join(
            has_products, &#34;mgi_accession_id&#34;, &#34;left_outer&#34;
        )
        gene_status_df = gene_status_df.withColumn(
            &#34;es_cell_production_status&#34;,
            when(
                (
                    col(&#34;es_cell_production_status&#34;).isNull()
                    | (col(&#34;es_cell_production_status&#34;) != &#34;ES Cells Produced&#34;)
                )
                &amp; (array_contains(&#34;product_types&#34;, &#34;es_cell&#34;)),
                lit(&#34;ES Cells Produced&#34;),
            ).otherwise(col(&#34;es_cell_production_status&#34;)),
        )
        gene_prod_status_map = {
            &#34;Aborted - ES Cell QC Failed&#34;: &#34;Selected for production&#34;,
            &#34;Assigned - ES Cell QC Complete&#34;: &#34;Selected for production&#34;,
            &#34;Assigned - ES Cell QC In Progress&#34;: &#34;Selected for production&#34;,
            &#34;Assigned&#34;: &#34;Selected for production&#34;,
            &#34;Conflict&#34;: &#34;Selected for production&#34;,
            &#34;Inspect - Conflict&#34;: &#34;Selected for production&#34;,
            &#34;Inspect - GLT Mouse&#34;: &#34;Selected for production&#34;,
            &#34;Inspect - MI Attempt&#34;: &#34;Selected for production&#34;,
            &#34;Interest&#34;: &#34;Selected for production&#34;,
            # Production statuses
            &#34;Chimeras obtained&#34;: &#34;Started&#34;,
            &#34;Chimeras/Founder Obtained&#34;: &#34;Started&#34;,
            &#34;Mouse Allele Modification Genotype Confirmed&#34;: &#34;Genotype confirmed mice&#34;,
            # Changed
            &#34;Cre Excision Started&#34;: &#34;Started&#34;,
            &#34;Founder obtained&#34;: &#34;Started&#34;,
            &#34;Micro-injection aborted&#34;: &#34;Started&#34;,
            &#34;Micro-injection in progress&#34;: &#34;Started&#34;,
            # Changed
            &#34;Cre Excision Complete&#34;: &#34;Started&#34;,
            &#34;Genotype confirmed&#34;: &#34;Genotype confirmed mice&#34;,
            &#34;Inactive&#34;: &#34;Withdrawn&#34;,
            &#34;Withdrawn&#34;: &#34;Withdrawn&#34;,
        }

        for status_col in gene_statuses_cols:
            if status_col not in [&#34;mgi_accession_id&#34;, &#34;phenotyping_status&#34;]:
                gene_status_df = map_status(
                    spark, gene_status_df, gene_prod_status_map, status_col
                )

        gentar_gene_prod_status_map = {
            &#34;Attempt In Progress&#34;: &#34;Started&#34;,
            &#34;Embryos Obtained&#34;: &#34;Started&#34;,
            &#34;Founder Obtained&#34;: &#34;Started&#34;,
            &#34;Genotype In Progress&#34;: &#34;Started&#34;,
            &#34;Genotype Not Confirmed&#34;: &#34;Started&#34;,
            &#34;Plan Created&#34;: &#34;Selected for production&#34;,
            &#34;Genotype Confirmed&#34;: &#34;Genotype Confirmed Mice&#34;,
            &#34;Abandoned&#34;: &#34;Withdrawn&#34;,
            &#34;Attempt Aborted&#34;: &#34;Withdrawn&#34;,
            &#34;Colony Aborted&#34;: &#34;Withdrawn&#34;,
            &#34;Genotype Extinct&#34;: &#34;Withdrawn&#34;,
            &#34;Inactive&#34;: &#34;Withdrawn&#34;,
            &#34;Plan Abandoned&#34;: &#34;Withdrawn&#34;,
        }

        for status_col in gene_statuses_cols:
            if status_col not in [&#34;mgi_accession_id&#34;, &#34;phenotyping_status&#34;]:
                gene_status_df = map_status(
                    spark, gene_status_df, gentar_gene_prod_status_map, status_col
                )
        phenotyping_status_map = {
            &#34;Phenotype Production Aborted&#34;: &#34;NULL&#34;,
            &#34;Phenotype Attempt Registered&#34;: &#34;Phenotype attempt registered&#34;,
            &#34;Phenotyping Registered&#34;: &#34;Phenotype attempt registered&#34;,
            &#34;Rederivation Complete&#34;: &#34;Phenotyping started&#34;,
            &#34;Rederivation Started&#34;: &#34;Phenotyping started&#34;,
            &#34;Phenotyping Started&#34;: &#34;Phenotyping started&#34;,
            &#34;Phenotyping All Data Processed&#34;: &#34;Phenotyping started&#34;,
            &#34;Phenotyping Complete&#34;: &#34;Phenotyping data available&#34;,
            &#34;Phenotyping Finished&#34;: &#34;Phenotyping finished&#34;,
        }

        get_status_hierarchy_udf = udf(
            lambda x: list(phenotyping_status_map.values()).index(
                phenotyping_status_map[x]
            )
            if x is not None
            else 0,
            IntegerType(),
        )
        gene_status_df = map_status(
            spark, gene_status_df, phenotyping_status_map, &#34;phenotyping_status&#34;
        )
        gene_status_df.select(gene_statuses_cols).distinct().write.parquet(output_path)


def _create_status_map(spark: SparkSession, status_map_dict: Dict) -&gt; DataFrame:
    status_map_df_json = spark.sparkContext.parallelize(
        [
            {
                &#34;src_production_status&#34;: key,
                &#34;dst_production_status&#34;: value,
            }
            for key, value in status_map_dict.items()
        ]
    )
    status_map_df = spark.read.json(status_map_df_json)
    return status_map_df


def map_status(
    spark: SparkSession,
    gene_status_df: DataFrame,
    status_map_dict: Dict,
    status_col_to_map: str,
) -&gt; DataFrame:
    status_map_df = _create_status_map(spark, status_map_dict)
    gene_status_df = gene_status_df.join(
        status_map_df,
        lower(col(status_col_to_map)) == lower(col(&#34;src_production_status&#34;)),
        &#34;left_outer&#34;,
    )
    gene_status_df = gene_status_df.withColumn(
        status_col_to_map,
        when(
            (
                col(&#34;dst_production_status&#34;).isNotNull()
                &amp; (col(&#34;dst_production_status&#34;) != &#34;NULL&#34;)
            ),
            col(&#34;dst_production_status&#34;),
        )
        .when(col(&#34;dst_production_status&#34;) == &#34;NULL&#34;, lit(None))
        .otherwise(col(status_col_to_map)),
    )
    gene_status_df = gene_status_df.drop(
        &#34;src_production_status&#34;, &#34;dst_production_status&#34;
    )
    return gene_status_df


def collapse_production_status(
    spark: SparkSession,
    gene_status_df: DataFrame,
    status_map_dict: Dict,
    src_status_list: List[str],
    target_status_col: str,
) -&gt; DataFrame:
    status_map_df = _create_status_map(spark, status_map_dict)

    gene_status_df = gene_status_df.withColumn(
        target_status_col, lit(None).astype(StringType())
    )
    get_status_hierarchy_udf = udf(
        lambda x: list(status_map_dict.values()).index(x) if x is not None else 0,
        IntegerType(),
    )

    for status_col in src_status_list:
        gene_status_df = gene_status_df.join(
            status_map_df,
            lower(col(status_col)) == lower(col(&#34;src_production_status&#34;)),
            &#34;left_outer&#34;,
        )
        gene_status_df = gene_status_df.withColumn(
            target_status_col,
            when(
                col(target_status_col).isNull()
                &amp; col(&#34;dst_production_status&#34;).isNotNull(),
                col(&#34;dst_production_status&#34;),
            )
            .when(
                get_status_hierarchy_udf(&#34;dst_production_status&#34;)
                &gt; get_status_hierarchy_udf(target_status_col),
                col(&#34;dst_production_status&#34;),
            )
            .otherwise(col(target_status_col)),
        )
        gene_status_df = gene_status_df.drop(
            &#34;src_production_status&#34;, &#34;dst_production_status&#34;
        )
    return gene_status_df</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.collapse_production_status"><code class="name flex">
<span>def <span class="ident">collapse_production_status</span></span>(<span>spark: pyspark.sql.session.SparkSession, gene_status_df: pyspark.sql.dataframe.DataFrame, status_map_dict: Dict[~KT, ~VT], src_status_list: List[str], target_status_col: str) ‑> pyspark.sql.dataframe.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collapse_production_status(
    spark: SparkSession,
    gene_status_df: DataFrame,
    status_map_dict: Dict,
    src_status_list: List[str],
    target_status_col: str,
) -&gt; DataFrame:
    status_map_df = _create_status_map(spark, status_map_dict)

    gene_status_df = gene_status_df.withColumn(
        target_status_col, lit(None).astype(StringType())
    )
    get_status_hierarchy_udf = udf(
        lambda x: list(status_map_dict.values()).index(x) if x is not None else 0,
        IntegerType(),
    )

    for status_col in src_status_list:
        gene_status_df = gene_status_df.join(
            status_map_df,
            lower(col(status_col)) == lower(col(&#34;src_production_status&#34;)),
            &#34;left_outer&#34;,
        )
        gene_status_df = gene_status_df.withColumn(
            target_status_col,
            when(
                col(target_status_col).isNull()
                &amp; col(&#34;dst_production_status&#34;).isNotNull(),
                col(&#34;dst_production_status&#34;),
            )
            .when(
                get_status_hierarchy_udf(&#34;dst_production_status&#34;)
                &gt; get_status_hierarchy_udf(target_status_col),
                col(&#34;dst_production_status&#34;),
            )
            .otherwise(col(target_status_col)),
        )
        gene_status_df = gene_status_df.drop(
            &#34;src_production_status&#34;, &#34;dst_production_status&#34;
        )
    return gene_status_df</code></pre>
</details>
</dd>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.map_status"><code class="name flex">
<span>def <span class="ident">map_status</span></span>(<span>spark: pyspark.sql.session.SparkSession, gene_status_df: pyspark.sql.dataframe.DataFrame, status_map_dict: Dict[~KT, ~VT], status_col_to_map: str) ‑> pyspark.sql.dataframe.DataFrame</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map_status(
    spark: SparkSession,
    gene_status_df: DataFrame,
    status_map_dict: Dict,
    status_col_to_map: str,
) -&gt; DataFrame:
    status_map_df = _create_status_map(spark, status_map_dict)
    gene_status_df = gene_status_df.join(
        status_map_df,
        lower(col(status_col_to_map)) == lower(col(&#34;src_production_status&#34;)),
        &#34;left_outer&#34;,
    )
    gene_status_df = gene_status_df.withColumn(
        status_col_to_map,
        when(
            (
                col(&#34;dst_production_status&#34;).isNotNull()
                &amp; (col(&#34;dst_production_status&#34;) != &#34;NULL&#34;)
            ),
            col(&#34;dst_production_status&#34;),
        )
        .when(col(&#34;dst_production_status&#34;) == &#34;NULL&#34;, lit(None))
        .otherwise(col(status_col_to_map)),
    )
    gene_status_df = gene_status_df.drop(
        &#34;src_production_status&#34;, &#34;dst_production_status&#34;
    )
    return gene_status_df</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor"><code class="flex name class">
<span>class <span class="ident">GeneProductionStatusExtractor</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>PySpark Task class to extract gene status information from tracking systems reports.
This also maps the different status in the reports to the ones we use on the website.
It takes as an input the Gene Interest report from gentar (<a href="https://www.gentar.org/tracker-api/api/reports/gene_interest">https://www.gentar.org/tracker-api/api/reports/gene_interest</a>)
And the Products report from Gentar ().
The output is a Parquet file containing a full report of the different Statuses available for a Gene.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeneProductionStatusExtractor(PySparkTask):
    &#34;&#34;&#34;
    PySpark Task class to extract gene status information from tracking systems reports.
    This also maps the different status in the reports to the ones we use on the website.
    It takes as an input the Gene Interest report from gentar (https://www.gentar.org/tracker-api/api/reports/gene_interest)
    And the Products report from Gentar ().
    The output is a Parquet file containing a full report of the different Statuses available for a Gene.
    &#34;&#34;&#34;

    #: Name of the Spark task
    name: str = &#34;IMPC_Gene_Production_Status_Extractor&#34;

    #: Path in the filesystem (local or HDFS) to the GenTar gene status report
    gentar_gene_status_path: luigi.Parameter = luigi.Parameter()

    #: Path of the output directory where the new parquet file will be generated.
    output_path = luigi.Parameter()

    def output(self):
        &#34;&#34;&#34;
        Returns the full parquet path as an output for the Luigi Task (e.g. impc/dr15.2/parquet/gene_status_parquet)
        &#34;&#34;&#34;
        return ImpcConfig().get_target(f&#34;{self.output_path}gene_status_parquet&#34;)

    def requires(self):
        &#34;&#34;&#34;
        Returns the list of dependencies for the PySpark task.
        &#34;&#34;&#34;
        return [ProductReportExtractor()]

    def app_options(self):
        &#34;&#34;&#34;
        Generates the options pass to the PySpark job
        &#34;&#34;&#34;
        return [
            # Output of the only dependency
            self.input()[0].path,
            self.gentar_gene_status_path,
            self.output().path,
        ]

    def main(self, sc: SparkContext, *args):
        &#34;&#34;&#34;
        Takes in a SparkContext and the list of arguments generated by `app_options` and executes the PySpark job.
        &#34;&#34;&#34;
        spark: SparkSession = SparkSession(sc)
        product_parquet_path = args[0]
        gentar_gene_status_path = args[1]
        output_path = args[2]

        gentar_gene_status_df = spark.read.csv(
            gentar_gene_status_path, header=True, sep=&#34;\t&#34;
        )

        product_df = spark.read.parquet(product_parquet_path)
        product_df = product_df.select(&#34;mgi_accession_id&#34;, &#34;type&#34;).distinct()
        has_products = product_df.groupBy(&#34;mgi_accession_id&#34;).agg(
            collect_set(&#34;type&#34;).alias(&#34;product_types&#34;)
        )

        # Renaming gentar TSV columns to match the gene core
        gentar_column_map = {
            &#34;Gene Symbol&#34;: &#34;marker_symbol&#34;,
            &#34;MGI ID&#34;: &#34;mgi_accession_id&#34;,
            &#34;Assignment Status&#34;: &#34;assignment_status&#34;,
            &#34;ES Null Production Status&#34;: &#34;null_allele_production_status&#34;,
            &#34;ES Conditional Production Status&#34;: &#34;conditional_allele_production_status&#34;,
            &#34;Crispr Production Status&#34;: &#34;crispr_allele_production_status&#34;,
            &#34;Early Adult Phenotyping Status&#34;: &#34;phenotyping_status&#34;,
        }
        for col_name in gentar_gene_status_df.columns:
            new_col_name = (
                gentar_column_map[col_name]
                if &#34;mgi_accession_id&#34; not in gentar_column_map[col_name]
                else gentar_column_map[col_name]
            )
            gentar_gene_status_df = gentar_gene_status_df.withColumnRenamed(
                col_name, new_col_name
            )
        gene_status_df = gentar_gene_status_df

        # Resolve assigment statuses
        gene_statuses_cols = [
            &#34;mgi_accession_id&#34;,
            &#34;assignment_status&#34;,
            &#34;null_allele_production_status&#34;,
            &#34;conditional_allele_production_status&#34;,
            &#34;crispr_allele_production_status&#34;,
            &#34;es_cell_production_status&#34;,
            &#34;mouse_production_status&#34;,
            &#34;phenotyping_status&#34;,
        ]

        mice_production_status_cols = [
            &#34;null_allele_production_status&#34;,
            &#34;conditional_allele_production_status&#34;,
            &#34;crispr_allele_production_status&#34;,
        ]

        allele_mouse_prod_status_map = {
            &#34;Chimeras obtained&#34;: &#34;Assigned for Mouse Production and Phenotyping&#34;,
            &#34;Micro-injection in progress&#34;: &#34;Assigned for Mouse Production and Phenotyping&#34;,
            &#34;Cre Excision Complete&#34;: &#34;Mice Produced&#34;,
            &#34;Cre Excision Started&#34;: &#34;Mice Produced&#34;,
            &#34;Genotype confirmed&#34;: &#34;Mice Produced&#34;,
            &#34;Phenotype Attempt Registered&#34;: &#34;Mice Produced&#34;,
            &#34;Rederivation Complete&#34;: &#34;Mice Produced&#34;,
            &#34;Rederivation Started&#34;: &#34;Mice Produced&#34;,
        }

        # Collapse mouse production status
        gene_status_df = collapse_production_status(
            spark,
            gene_status_df,
            allele_mouse_prod_status_map,
            mice_production_status_cols,
            &#34;mouse_production_status&#34;,
        )

        assignment_status_es_cells_prod_status_map = {
            &#34;Aborted - ES Cell QC Failed&#34;: &#34;Not Assigned for ES Cell Production&#34;,
            &#34;Assigned - ES Cell QC In Progress&#34;: &#34;Assigned for ES Cell Production&#34;,
            &#34;Assigned - ES Cell QC Complete&#34;: &#34;ES Cells Produced&#34;,
        }

        # Collapse ES Cells production status
        gene_status_df = collapse_production_status(
            spark,
            gene_status_df,
            assignment_status_es_cells_prod_status_map,
            [&#34;null_allele_production_status&#34;, &#34;conditional_allele_production_status&#34;],
            &#34;es_cell_production_status&#34;,
        )

        # Map ES Cell production status
        allele_es_cells_prod_status_map = {
            &#34;Micro-injection in progress&#34;: &#34;Assigned for ES Cell Production&#34;,
            &#34;Chimeras obtained&#34;: &#34;ES Cells Produced&#34;,
            &#34;Genotype confirmed&#34;: &#34;ES Cells Produced&#34;,
            &#34;Micro-injection aborted&#34;: &#34;Not Assigned for ES Cell Production&#34;,
        }

        map_allele_es_cells_udf = udf(
            lambda x: allele_es_cells_prod_status_map[x]
            if x in allele_es_cells_prod_status_map
            else None,
            StringType(),
        )

        gene_status_df = gene_status_df.withColumn(
            &#34;es_cell_production_status&#34;,
            map_allele_es_cells_udf(&#34;conditional_allele_production_status&#34;),
        )
        gene_status_df = gene_status_df.join(
            has_products, &#34;mgi_accession_id&#34;, &#34;left_outer&#34;
        )
        gene_status_df = gene_status_df.withColumn(
            &#34;es_cell_production_status&#34;,
            when(
                (
                    col(&#34;es_cell_production_status&#34;).isNull()
                    | (col(&#34;es_cell_production_status&#34;) != &#34;ES Cells Produced&#34;)
                )
                &amp; (array_contains(&#34;product_types&#34;, &#34;es_cell&#34;)),
                lit(&#34;ES Cells Produced&#34;),
            ).otherwise(col(&#34;es_cell_production_status&#34;)),
        )
        gene_prod_status_map = {
            &#34;Aborted - ES Cell QC Failed&#34;: &#34;Selected for production&#34;,
            &#34;Assigned - ES Cell QC Complete&#34;: &#34;Selected for production&#34;,
            &#34;Assigned - ES Cell QC In Progress&#34;: &#34;Selected for production&#34;,
            &#34;Assigned&#34;: &#34;Selected for production&#34;,
            &#34;Conflict&#34;: &#34;Selected for production&#34;,
            &#34;Inspect - Conflict&#34;: &#34;Selected for production&#34;,
            &#34;Inspect - GLT Mouse&#34;: &#34;Selected for production&#34;,
            &#34;Inspect - MI Attempt&#34;: &#34;Selected for production&#34;,
            &#34;Interest&#34;: &#34;Selected for production&#34;,
            # Production statuses
            &#34;Chimeras obtained&#34;: &#34;Started&#34;,
            &#34;Chimeras/Founder Obtained&#34;: &#34;Started&#34;,
            &#34;Mouse Allele Modification Genotype Confirmed&#34;: &#34;Genotype confirmed mice&#34;,
            # Changed
            &#34;Cre Excision Started&#34;: &#34;Started&#34;,
            &#34;Founder obtained&#34;: &#34;Started&#34;,
            &#34;Micro-injection aborted&#34;: &#34;Started&#34;,
            &#34;Micro-injection in progress&#34;: &#34;Started&#34;,
            # Changed
            &#34;Cre Excision Complete&#34;: &#34;Started&#34;,
            &#34;Genotype confirmed&#34;: &#34;Genotype confirmed mice&#34;,
            &#34;Inactive&#34;: &#34;Withdrawn&#34;,
            &#34;Withdrawn&#34;: &#34;Withdrawn&#34;,
        }

        for status_col in gene_statuses_cols:
            if status_col not in [&#34;mgi_accession_id&#34;, &#34;phenotyping_status&#34;]:
                gene_status_df = map_status(
                    spark, gene_status_df, gene_prod_status_map, status_col
                )

        gentar_gene_prod_status_map = {
            &#34;Attempt In Progress&#34;: &#34;Started&#34;,
            &#34;Embryos Obtained&#34;: &#34;Started&#34;,
            &#34;Founder Obtained&#34;: &#34;Started&#34;,
            &#34;Genotype In Progress&#34;: &#34;Started&#34;,
            &#34;Genotype Not Confirmed&#34;: &#34;Started&#34;,
            &#34;Plan Created&#34;: &#34;Selected for production&#34;,
            &#34;Genotype Confirmed&#34;: &#34;Genotype Confirmed Mice&#34;,
            &#34;Abandoned&#34;: &#34;Withdrawn&#34;,
            &#34;Attempt Aborted&#34;: &#34;Withdrawn&#34;,
            &#34;Colony Aborted&#34;: &#34;Withdrawn&#34;,
            &#34;Genotype Extinct&#34;: &#34;Withdrawn&#34;,
            &#34;Inactive&#34;: &#34;Withdrawn&#34;,
            &#34;Plan Abandoned&#34;: &#34;Withdrawn&#34;,
        }

        for status_col in gene_statuses_cols:
            if status_col not in [&#34;mgi_accession_id&#34;, &#34;phenotyping_status&#34;]:
                gene_status_df = map_status(
                    spark, gene_status_df, gentar_gene_prod_status_map, status_col
                )
        phenotyping_status_map = {
            &#34;Phenotype Production Aborted&#34;: &#34;NULL&#34;,
            &#34;Phenotype Attempt Registered&#34;: &#34;Phenotype attempt registered&#34;,
            &#34;Phenotyping Registered&#34;: &#34;Phenotype attempt registered&#34;,
            &#34;Rederivation Complete&#34;: &#34;Phenotyping started&#34;,
            &#34;Rederivation Started&#34;: &#34;Phenotyping started&#34;,
            &#34;Phenotyping Started&#34;: &#34;Phenotyping started&#34;,
            &#34;Phenotyping All Data Processed&#34;: &#34;Phenotyping started&#34;,
            &#34;Phenotyping Complete&#34;: &#34;Phenotyping data available&#34;,
            &#34;Phenotyping Finished&#34;: &#34;Phenotyping finished&#34;,
        }

        get_status_hierarchy_udf = udf(
            lambda x: list(phenotyping_status_map.values()).index(
                phenotyping_status_map[x]
            )
            if x is not None
            else 0,
            IntegerType(),
        )
        gene_status_df = map_status(
            spark, gene_status_df, phenotyping_status_map, &#34;phenotyping_status&#34;
        )
        gene_status_df.select(gene_statuses_cols).distinct().write.parquet(output_path)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>luigi.contrib.spark.PySparkTask</li>
<li>luigi.contrib.spark.SparkSubmitTask</li>
<li>luigi.contrib.external_program.ExternalProgramTask</li>
<li>luigi.task.Task</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.gentar_gene_status_path"><code class="name">var <span class="ident">gentar_gene_status_path</span> : luigi.parameter.Parameter</code></dt>
<dd>
<div class="desc"><p>Path in the filesystem (local or HDFS) to the GenTar gene status report</p></div>
</dd>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>Name of the Spark task</p></div>
</dd>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.output_path"><code class="name">var <span class="ident">output_path</span></code></dt>
<dd>
<div class="desc"><p>Path of the output directory where the new parquet file will be generated.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.app_options"><code class="name flex">
<span>def <span class="ident">app_options</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates the options pass to the PySpark job</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def app_options(self):
    &#34;&#34;&#34;
    Generates the options pass to the PySpark job
    &#34;&#34;&#34;
    return [
        # Output of the only dependency
        self.input()[0].path,
        self.gentar_gene_status_path,
        self.output().path,
    ]</code></pre>
</details>
</dd>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>self, sc: pyspark.context.SparkContext, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in a SparkContext and the list of arguments generated by <code>app_options</code> and executes the PySpark job.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main(self, sc: SparkContext, *args):
    &#34;&#34;&#34;
    Takes in a SparkContext and the list of arguments generated by `app_options` and executes the PySpark job.
    &#34;&#34;&#34;
    spark: SparkSession = SparkSession(sc)
    product_parquet_path = args[0]
    gentar_gene_status_path = args[1]
    output_path = args[2]

    gentar_gene_status_df = spark.read.csv(
        gentar_gene_status_path, header=True, sep=&#34;\t&#34;
    )

    product_df = spark.read.parquet(product_parquet_path)
    product_df = product_df.select(&#34;mgi_accession_id&#34;, &#34;type&#34;).distinct()
    has_products = product_df.groupBy(&#34;mgi_accession_id&#34;).agg(
        collect_set(&#34;type&#34;).alias(&#34;product_types&#34;)
    )

    # Renaming gentar TSV columns to match the gene core
    gentar_column_map = {
        &#34;Gene Symbol&#34;: &#34;marker_symbol&#34;,
        &#34;MGI ID&#34;: &#34;mgi_accession_id&#34;,
        &#34;Assignment Status&#34;: &#34;assignment_status&#34;,
        &#34;ES Null Production Status&#34;: &#34;null_allele_production_status&#34;,
        &#34;ES Conditional Production Status&#34;: &#34;conditional_allele_production_status&#34;,
        &#34;Crispr Production Status&#34;: &#34;crispr_allele_production_status&#34;,
        &#34;Early Adult Phenotyping Status&#34;: &#34;phenotyping_status&#34;,
    }
    for col_name in gentar_gene_status_df.columns:
        new_col_name = (
            gentar_column_map[col_name]
            if &#34;mgi_accession_id&#34; not in gentar_column_map[col_name]
            else gentar_column_map[col_name]
        )
        gentar_gene_status_df = gentar_gene_status_df.withColumnRenamed(
            col_name, new_col_name
        )
    gene_status_df = gentar_gene_status_df

    # Resolve assigment statuses
    gene_statuses_cols = [
        &#34;mgi_accession_id&#34;,
        &#34;assignment_status&#34;,
        &#34;null_allele_production_status&#34;,
        &#34;conditional_allele_production_status&#34;,
        &#34;crispr_allele_production_status&#34;,
        &#34;es_cell_production_status&#34;,
        &#34;mouse_production_status&#34;,
        &#34;phenotyping_status&#34;,
    ]

    mice_production_status_cols = [
        &#34;null_allele_production_status&#34;,
        &#34;conditional_allele_production_status&#34;,
        &#34;crispr_allele_production_status&#34;,
    ]

    allele_mouse_prod_status_map = {
        &#34;Chimeras obtained&#34;: &#34;Assigned for Mouse Production and Phenotyping&#34;,
        &#34;Micro-injection in progress&#34;: &#34;Assigned for Mouse Production and Phenotyping&#34;,
        &#34;Cre Excision Complete&#34;: &#34;Mice Produced&#34;,
        &#34;Cre Excision Started&#34;: &#34;Mice Produced&#34;,
        &#34;Genotype confirmed&#34;: &#34;Mice Produced&#34;,
        &#34;Phenotype Attempt Registered&#34;: &#34;Mice Produced&#34;,
        &#34;Rederivation Complete&#34;: &#34;Mice Produced&#34;,
        &#34;Rederivation Started&#34;: &#34;Mice Produced&#34;,
    }

    # Collapse mouse production status
    gene_status_df = collapse_production_status(
        spark,
        gene_status_df,
        allele_mouse_prod_status_map,
        mice_production_status_cols,
        &#34;mouse_production_status&#34;,
    )

    assignment_status_es_cells_prod_status_map = {
        &#34;Aborted - ES Cell QC Failed&#34;: &#34;Not Assigned for ES Cell Production&#34;,
        &#34;Assigned - ES Cell QC In Progress&#34;: &#34;Assigned for ES Cell Production&#34;,
        &#34;Assigned - ES Cell QC Complete&#34;: &#34;ES Cells Produced&#34;,
    }

    # Collapse ES Cells production status
    gene_status_df = collapse_production_status(
        spark,
        gene_status_df,
        assignment_status_es_cells_prod_status_map,
        [&#34;null_allele_production_status&#34;, &#34;conditional_allele_production_status&#34;],
        &#34;es_cell_production_status&#34;,
    )

    # Map ES Cell production status
    allele_es_cells_prod_status_map = {
        &#34;Micro-injection in progress&#34;: &#34;Assigned for ES Cell Production&#34;,
        &#34;Chimeras obtained&#34;: &#34;ES Cells Produced&#34;,
        &#34;Genotype confirmed&#34;: &#34;ES Cells Produced&#34;,
        &#34;Micro-injection aborted&#34;: &#34;Not Assigned for ES Cell Production&#34;,
    }

    map_allele_es_cells_udf = udf(
        lambda x: allele_es_cells_prod_status_map[x]
        if x in allele_es_cells_prod_status_map
        else None,
        StringType(),
    )

    gene_status_df = gene_status_df.withColumn(
        &#34;es_cell_production_status&#34;,
        map_allele_es_cells_udf(&#34;conditional_allele_production_status&#34;),
    )
    gene_status_df = gene_status_df.join(
        has_products, &#34;mgi_accession_id&#34;, &#34;left_outer&#34;
    )
    gene_status_df = gene_status_df.withColumn(
        &#34;es_cell_production_status&#34;,
        when(
            (
                col(&#34;es_cell_production_status&#34;).isNull()
                | (col(&#34;es_cell_production_status&#34;) != &#34;ES Cells Produced&#34;)
            )
            &amp; (array_contains(&#34;product_types&#34;, &#34;es_cell&#34;)),
            lit(&#34;ES Cells Produced&#34;),
        ).otherwise(col(&#34;es_cell_production_status&#34;)),
    )
    gene_prod_status_map = {
        &#34;Aborted - ES Cell QC Failed&#34;: &#34;Selected for production&#34;,
        &#34;Assigned - ES Cell QC Complete&#34;: &#34;Selected for production&#34;,
        &#34;Assigned - ES Cell QC In Progress&#34;: &#34;Selected for production&#34;,
        &#34;Assigned&#34;: &#34;Selected for production&#34;,
        &#34;Conflict&#34;: &#34;Selected for production&#34;,
        &#34;Inspect - Conflict&#34;: &#34;Selected for production&#34;,
        &#34;Inspect - GLT Mouse&#34;: &#34;Selected for production&#34;,
        &#34;Inspect - MI Attempt&#34;: &#34;Selected for production&#34;,
        &#34;Interest&#34;: &#34;Selected for production&#34;,
        # Production statuses
        &#34;Chimeras obtained&#34;: &#34;Started&#34;,
        &#34;Chimeras/Founder Obtained&#34;: &#34;Started&#34;,
        &#34;Mouse Allele Modification Genotype Confirmed&#34;: &#34;Genotype confirmed mice&#34;,
        # Changed
        &#34;Cre Excision Started&#34;: &#34;Started&#34;,
        &#34;Founder obtained&#34;: &#34;Started&#34;,
        &#34;Micro-injection aborted&#34;: &#34;Started&#34;,
        &#34;Micro-injection in progress&#34;: &#34;Started&#34;,
        # Changed
        &#34;Cre Excision Complete&#34;: &#34;Started&#34;,
        &#34;Genotype confirmed&#34;: &#34;Genotype confirmed mice&#34;,
        &#34;Inactive&#34;: &#34;Withdrawn&#34;,
        &#34;Withdrawn&#34;: &#34;Withdrawn&#34;,
    }

    for status_col in gene_statuses_cols:
        if status_col not in [&#34;mgi_accession_id&#34;, &#34;phenotyping_status&#34;]:
            gene_status_df = map_status(
                spark, gene_status_df, gene_prod_status_map, status_col
            )

    gentar_gene_prod_status_map = {
        &#34;Attempt In Progress&#34;: &#34;Started&#34;,
        &#34;Embryos Obtained&#34;: &#34;Started&#34;,
        &#34;Founder Obtained&#34;: &#34;Started&#34;,
        &#34;Genotype In Progress&#34;: &#34;Started&#34;,
        &#34;Genotype Not Confirmed&#34;: &#34;Started&#34;,
        &#34;Plan Created&#34;: &#34;Selected for production&#34;,
        &#34;Genotype Confirmed&#34;: &#34;Genotype Confirmed Mice&#34;,
        &#34;Abandoned&#34;: &#34;Withdrawn&#34;,
        &#34;Attempt Aborted&#34;: &#34;Withdrawn&#34;,
        &#34;Colony Aborted&#34;: &#34;Withdrawn&#34;,
        &#34;Genotype Extinct&#34;: &#34;Withdrawn&#34;,
        &#34;Inactive&#34;: &#34;Withdrawn&#34;,
        &#34;Plan Abandoned&#34;: &#34;Withdrawn&#34;,
    }

    for status_col in gene_statuses_cols:
        if status_col not in [&#34;mgi_accession_id&#34;, &#34;phenotyping_status&#34;]:
            gene_status_df = map_status(
                spark, gene_status_df, gentar_gene_prod_status_map, status_col
            )
    phenotyping_status_map = {
        &#34;Phenotype Production Aborted&#34;: &#34;NULL&#34;,
        &#34;Phenotype Attempt Registered&#34;: &#34;Phenotype attempt registered&#34;,
        &#34;Phenotyping Registered&#34;: &#34;Phenotype attempt registered&#34;,
        &#34;Rederivation Complete&#34;: &#34;Phenotyping started&#34;,
        &#34;Rederivation Started&#34;: &#34;Phenotyping started&#34;,
        &#34;Phenotyping Started&#34;: &#34;Phenotyping started&#34;,
        &#34;Phenotyping All Data Processed&#34;: &#34;Phenotyping started&#34;,
        &#34;Phenotyping Complete&#34;: &#34;Phenotyping data available&#34;,
        &#34;Phenotyping Finished&#34;: &#34;Phenotyping finished&#34;,
    }

    get_status_hierarchy_udf = udf(
        lambda x: list(phenotyping_status_map.values()).index(
            phenotyping_status_map[x]
        )
        if x is not None
        else 0,
        IntegerType(),
    )
    gene_status_df = map_status(
        spark, gene_status_df, phenotyping_status_map, &#34;phenotyping_status&#34;
    )
    gene_status_df.select(gene_statuses_cols).distinct().write.parquet(output_path)</code></pre>
</details>
</dd>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.output"><code class="name flex">
<span>def <span class="ident">output</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the full parquet path as an output for the Luigi Task (e.g. impc/dr15.2/parquet/gene_status_parquet)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output(self):
    &#34;&#34;&#34;
    Returns the full parquet path as an output for the Luigi Task (e.g. impc/dr15.2/parquet/gene_status_parquet)
    &#34;&#34;&#34;
    return ImpcConfig().get_target(f&#34;{self.output_path}gene_status_parquet&#34;)</code></pre>
</details>
</dd>
<dt id="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.requires"><code class="name flex">
<span>def <span class="ident">requires</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the list of dependencies for the PySpark task.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires(self):
    &#34;&#34;&#34;
    Returns the list of dependencies for the PySpark task.
    &#34;&#34;&#34;
    return [ProductReportExtractor()]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<div style="max-width: 300px; text-align: center">
<img src="https://www.mousephenotype.org/wp-content/themes/impc/images/IMPC_10_YEAR_Logo.svg" alt="IMPC Logo">
</div>
<h1 style="text-align: center; max-width: 300px;">IMPC ETL</h1>
<h2 style="text-align: center; max-width: 300px;">Reference Documentation</h2>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="impc_etl.jobs.extract" href="index.html">impc_etl.jobs.extract</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.collapse_production_status" href="#impc_etl.jobs.extract.gene_production_status_extractor.collapse_production_status">collapse_production_status</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.map_status" href="#impc_etl.jobs.extract.gene_production_status_extractor.map_status">map_status</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor">GeneProductionStatusExtractor</a></code></h4>
<ul class="">
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.app_options" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.app_options">app_options</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.gentar_gene_status_path" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.gentar_gene_status_path">gentar_gene_status_path</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.main" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.main">main</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.name" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.name">name</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.output" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.output">output</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.output_path" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.output_path">output_path</a></code></li>
<li><code><a title="impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.requires" href="#impc_etl.jobs.extract.gene_production_status_extractor.GeneProductionStatusExtractor.requires">requires</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span></span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>